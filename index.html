<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ラインスキャン判定＋タイムライン＋ストップウォッチ</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  :root { font-family: 'Inter', sans-serif; }
  #result-container { overflow-x: auto; white-space: nowrap; cursor: grab; position: relative; background:#111; }
  #capture-canvas { position: fixed; top: -9999px; left: -9999px; }
  #video { width: 100%; height: 100%; object-fit: cover; position: absolute; top:0; left:0; z-index:10; }
  .scan-line { position:absolute; top:0; height:100%; pointer-events:none; opacity:0.75; z-index:30; width:2px; background:red;}
  .timeline-line { position:absolute; top:0; height:100%; width:2px; pointer-events:auto; cursor:grab; z-index:50; }
</style>
</head>
<body class="bg-gray-100 min-h-screen p-4 md:p-8">
<div class="max-w-5xl mx-auto">
<h1 class="text-3xl font-extrabold text-indigo-700 mb-6 text-center">📸 ラインスキャン判定＋タイムライン＋ストップウォッチ</h1>

<div class="bg-white p-5 rounded-xl shadow-lg mb-6 flex flex-wrap gap-4 items-center">
  <button id="setup-camera-button" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg shadow-md">📷 カメラ起動</button>
  <button id="sw-start" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg shadow-md">⏱️ 開始</button>
  <button id="sw-stop" class="bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-4 rounded-lg shadow-md">⏹️ 停止</button>
  <button id="sw-reset" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-3 px-4 rounded-lg shadow-md">🔄 リセット</button>
  <span id="sw-display" class="ml-4 font-bold text-lg">0.00 s</span>
</div>

<div id="video-wrapper" class="relative w-full aspect-video bg-gray-800 rounded-xl overflow-hidden shadow-2xl mb-6 flex justify-center items-center">
  <video id="video" playsinline autoplay muted class="hidden"></video>
  <p id="video-placeholder" class="text-white text-center z-20">カメラ映像の準備中...</p>
  <div id="scan-line" class="scan-line"></div>
</div>

<div class="bg-white p-5 rounded-xl shadow-lg mb-6 flex flex-col md:flex-row gap-4 items-center">
  <div class="flex items-center space-x-4">
    <label for="scan-offset" class="text-gray-700 text-sm font-semibold whitespace-nowrap">判定ライン位置:</label>
    <input type="range" id="scan-offset" min="-150" max="150" value="0" step="1" class="w-48 h-2 bg-gray-200 rounded-lg cursor-pointer">
    <span id="offset-value" class="text-indigo-600 font-bold w-10 text-right">0</span>
  </div>
  <div class="flex items-center space-x-4">
    <label for="slit-width" class="text-gray-700 text-sm font-semibold">スリット幅:</label>
    <input type="range" id="slit-width" min="1" max="10" value="2" step="1" class="w-32 h-2 bg-gray-200 rounded-lg cursor-pointer">
    <span id="slit-value" class="text-indigo-600 font-bold w-6 text-right">2</span>
  </div>
</div>

<h2 class="text-xl font-semibold text-gray-800 mb-3">判定結果 (ラインスキャン画像)</h2>
<div id="result-container" class="w-full h-80 bg-gray-900 rounded-xl shadow-inner border border-gray-300 overflow-x-scroll relative">
  <canvas id="result-canvas" class="h-full"></canvas>
</div>
<p class="text-sm text-gray-600 mt-2">左右にスクロールして着順を確認してください。クリックで縦線（タイムライン）を追加可能。</p>

<div class="mt-6 text-center">
  <button id="download-button" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg hidden">⬇️ 判定画像をダウンロード</button>
</div>

<canvas id="capture-canvas"></canvas>

<script>
const video = document.getElementById('video');
const captureCanvas = document.getElementById('capture-canvas');
const captureCtx = captureCanvas.getContext('2d');
const resultCanvas = document.getElementById('result-canvas');
const resultCtx = resultCanvas.getContext('2d');
const setupCameraButton = document.getElementById('setup-camera-button');
const scanOffsetInput = document.getElementById('scan-offset');
const offsetValueSpan = document.getElementById('offset-value');
const slitInput = document.getElementById('slit-width');
const slitValueSpan = document.getElementById('slit-value');
const resultContainer = document.getElementById('result-container');
const scanLine = document.getElementById('scan-line');
const swDisplay = document.getElementById('sw-display');
const swStart = document.getElementById('sw-start');
const swStop = document.getElementById('sw-stop');
const swReset = document.getElementById('sw-reset');
const downloadButton = document.getElementById('download-button');

let stream=null, scanning=false, animationFrameId=null;
let scanX=0, FRAME_HEIGHT=320;
let columnTimes=[];
let timelines=[]; // {x,color}
let stopwatchStart=null, stopwatchElapsed=0, stopwatchInterval=null;

// スリット位置と幅設定
scanOffsetInput.addEventListener('input',e=>{
  const val=parseInt(e.target.value);
  offsetValueSpan.textContent=val;
  scanLine.style.left=`calc(50% + ${val}px)`;
});
slitInput.addEventListener('input',e=>{
  const val=parseInt(e.target.value);
  slitValueSpan.textContent=val;
});

// ストップウォッチ
function updateSWDisplay(){
  if(stopwatchStart) stopwatchElapsed = performance.now() - stopwatchStart;
  swDisplay.textContent = (stopwatchElapsed/1000).toFixed(2) + ' s';
}
swStart.addEventListener('click',()=>{
  if(!stopwatchStart) stopwatchStart = performance.now() - stopwatchElapsed;
  if(!stopwatchInterval) stopwatchInterval = setInterval(updateSWDisplay,33);
});
swStop.addEventListener('click',()=>{ stopwatchStart=null; clearInterval(stopwatchInterval); stopwatchInterval=null; });
swReset.addEventListener('click'=>{ stopwatchStart=null; stopwatchElapsed=0; updateSWDisplay(); clearInterval(stopwatchInterval); stopwatchInterval=null; });

// カメラ起動
setupCameraButton.addEventListener('click',async()=>{
  if(stream){stream.getTracks().forEach(t=>t.stop()); stream=null;}
  try{
    stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment',frameRate:{ideal:60}},audio:false});
    video.srcObject=stream; await video.play(); video.classList.remove('hidden');
    messageBox=document.getElementById('message-box');
    messageBox.className='bg-green-100 border-l-4 border-green-500 text-green-800 p-4 rounded-lg mb-6 shadow-md';
    messageBox.innerHTML='<p class="font-bold">✅ カメラ準備完了</p>';
  }catch(err){ alert('カメラ起動失敗: '+err.message);}
});

// スキャン開始
function startScanning(){
  if(!stream){ alert('カメラを起動してください'); return; }
  scanning=true; scanX=0; columnTimes=[]; resultCanvas.width=1; resultCtx.clearRect(0,0,resultCanvas.width,resultCanvas.height);
  animationFrameId=requestAnimationFrame(processFrame);
}
function stopScanning(){ scanning=false; cancelAnimationFrame(animationFrameId); stopwatchStart=null; clearInterval(stopwatchInterval); stopwatchInterval=null; }

// スキャン処理
function processFrame(){
  if(!scanning||video.paused||video.ended) return;
  captureCanvas.width=video.videoWidth; captureCanvas.height=video.videoHeight;
  captureCtx.drawImage(video,0,0,captureCanvas.width,captureCanvas.height);
  const offset=parseInt(scanOffsetInput.value);
  const slit=parseInt(slitInput.value);
  const x = Math.floor(captureCanvas.width/2)+offset;

  // 時間記録
  const time = performance.now()/1000;
  columnTimes.push(time);

  // 結果キャンバス更新
  const resultWidth=resultCanvas.width;
  const imageData=captureCtx.getImageData(x,0,slit,captureCanvas.height);
  const tempCanvas=document.createElement('canvas');
  tempCanvas.width=slit; tempCanvas.height=captureCanvas.height;
  tempCanvas.getContext('2d').putImageData(imageData,0,0);
  resultCanvas.width=resultWidth+slit; resultCanvas.height=FRAME_HEIGHT;
  resultCtx.drawImage(tempCanvas,resultWidth,0,slit,FRAME_HEIGHT);

  // 縦線描画＆タイム表示
  timelines.forEach(t=>{
    resultCtx.strokeStyle = t.color; resultCtx.lineWidth=2;
    resultCtx.beginPath();
    resultCtx.moveTo(t.x,0);
    resultCtx.lineTo(t.x,FRAME_HEIGHT);
    resultCtx.stroke();
    // 時間表示
    const idx = Math.min(Math.floor(t.x), columnTimes.length-1);
    const displayTime = columnTimes[idx]!==undefined ? columnTimes[idx].toFixed(2)+'s':'-';
    resultCtx.fillStyle='rgba(0,0,0,0.6)';
    resultCtx.fillRect(t.x-20,0,40,18);
    resultCtx.fillStyle='white';
    resultCtx.font='12px sans-serif';
    resultCtx.textAlign='center';
    resultCtx.fillText(displayTime, t.x, 14);
  });

  scanX++;
  resultContainer.scrollLeft=resultContainer.scrollWidth;
  if(scanning) animationFrameId=requestAnimationFrame(processFrame);
}

// クリックで縦線追加
resultCanvas.addEventListener('click',e=>{
  const rect=resultCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left + resultContainer.scrollLeft;
  timelines.push({x,color:`hsl(${Math.random()*360},80%,60%)`});
});

// 縦線ドラッグ
let draggingTimeline=null, dragStartX=0;
resultCanvas.addEventListener('mousedown', e=>{
  const rect=resultCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left + resultContainer.scrollLeft;
  timelines.forEach(t=>{ if(Math.abs(x-t.x)<5){ draggingTimeline=t; dragStartX=x; }});
});
document.addEventListener('mousemove', e=>{
  if(!draggingTimeline) return;
  const rect=resultCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left + resultContainer.scrollLeft;
  draggingTimeline.x += x - dragStartX; dragStartX = x;
});
document.addEventListener('mouseup',()=>{ draggingTimeline=null; });

// 結果ダウンロード
downloadButton.addEventListener('click',()=>{
  const a=document.createElement('a'); a.href=resultCanvas.toDataURL('image/png'); a.download=`LineScan_${Date.now()}.png`; a.click();
});
</script>
</body>
</html>
